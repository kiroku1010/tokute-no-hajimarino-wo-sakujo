<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å˜èªå‰Šé™¤ãƒ„ãƒ¼ãƒ«</title>
    <style>
        /* ç°¡å˜ãªã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚° */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        textarea {
            width: 100%;
            height: 200px;
            margin-bottom: 10px;
            padding: 10px;
            box-sizing: border-box;
            border: 1px solid #ccc;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        button {
            padding: 10px 15px;
            background-color: #007bff;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
    </style>
</head>
<body>

    <h1>ğŸ“ ç‰¹å®šã®å˜èªã‚’å‰Šé™¤ï¼ˆè¡Œä¿æŒï¼‰</h1>
    <p>æŒ‡å®šã•ã‚ŒãŸãƒ‘ã‚¿ãƒ¼ãƒ³ã§å§‹ã¾ã‚‹å˜èªã‚’å‰Šé™¤ã—ã€å…ƒã®è¡Œæ•°ã‚’ä¿ã¡ã¾ã™ã€‚</p>

    <label for="inputText">å…¥åŠ›ãƒ†ã‚­ã‚¹ãƒˆ:</label>
    <textarea id="inputText" placeholder="ã“ã“ã«ãƒ†ã‚­ã‚¹ãƒˆã‚’å…¥åŠ›ã—ã¦ãã ã•ã„..."></textarea>

    <button onclick="processText()">å˜èªã‚’å‰Šé™¤ã—ã¦å‡¦ç†</button>

    <label for="outputText">å‡ºåŠ›çµæœ:</label>
    <textarea id="outputText" readonly placeholder="å‡¦ç†çµæœãŒã“ã“ã«è¡¨ç¤ºã•ã‚Œã¾ã™..."></textarea>

    <script>
        /**
         * ãƒ†ã‚­ã‚¹ãƒˆã‚’å‡¦ç†ã—ã€ç‰¹å®šã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã§å§‹ã¾ã‚‹å˜èªã€ã¾ãŸã¯ç‰¹å®šæ–‡å­—åˆ—ã‚’å«ã‚€å˜èªã‚’å‰Šé™¤ã—ã¾ã™ã€‚
         * ã¾ãŸã€å¾Œè€…ã®æ¡ä»¶ã«è©²å½“ã™ã‚‹å˜èªã‚’å«ã‚€è¡Œã¯ç©ºè¡Œã«ãªã‚Šã¾ã™ã€‚
         */
        function processText() {
            // 1. è¦ç´ ã®å–å¾—
            const inputTextarea = document.getElementById('inputText');
            const outputTextarea = document.getElementById('outputText');
            const originalText = inputTextarea.value;

            // 2. å‰Šé™¤ãƒ‘ã‚¿ãƒ¼ãƒ³ã®å®šç¾©
            // A. å˜èªã®å…ˆé ­ã«ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ (æ—¢å­˜ã®ãƒªã‚¹ãƒˆ)
            const startingPatterns = [
                'ky', 'kw', 'sy', 'sh', 'sw', 'ty', 'th', 'ts', 'tw', 'cy', 'ch',
                'ny', 'hy', 'hw', 'fy', 'my', 'ry', 'wy', 'gy', 'zy', 'dy', 'dh',
                'by', 'py', 'ly', 'lw', 'xy', 'xw', 'xn'
            ].join('|');
            
            // B. å˜èªå†…ã®ã©ã“ã‹ã«å«ã¾ã‚Œã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ï¼ˆæ–°æ©Ÿèƒ½ã®ãƒˆãƒªã‚¬ãƒ¼ï¼‰
            const containingPatterns = ['zh', 'zj', 'zk', 'zl'];
            const containingRegex = new RegExp('(' + containingPatterns.join('|') + ')', 'gi');

            // C. æœ€åˆã®å‰Šé™¤å‡¦ç†ç”¨ã®æ­£è¦è¡¨ç¾ (å˜èªã®å…ˆé ­)
            // \b(ãƒ‘ã‚¿ãƒ¼ãƒ³)\w* ã«ãƒãƒƒãƒ
            const startingRegex = new RegExp('\\b(' + startingPatterns + ')\\w*', 'gi');

            // 3. ãƒ†ã‚­ã‚¹ãƒˆã‚’è¡Œã”ã¨ã«å‡¦ç†
            const lines = originalText.split('\n');
            let shouldEmptyLine = false; // è¡Œã‚’ç©ºã«ã™ã‚‹ã‹ã©ã†ã‹ã®ãƒ•ãƒ©ã‚°

            const processedLines = lines.map(line => {
                // A. ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
                shouldEmptyLine = false; 

                // B. æœ€åˆã«ã€å˜èªã®å…ˆé ­ã«ãƒãƒƒãƒã™ã‚‹ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å‰Šé™¤
                let processedLine = line.replace(startingRegex, '');

                // C. ã€Œzh, zj, zk, zlã€ã‚’å«ã‚€å˜èªã‚’æ¤œç´¢ãƒ»å‰Šé™¤
                // ã“ã®å‰Šé™¤ã‚’è¡Œã†å‰ã«ã€è©²å½“ãƒ‘ã‚¿ãƒ¼ãƒ³ãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ã—ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                
                // è¡Œå†…ã§ã€containingPatternsã‚’å«ã‚€å˜èªãŒã‚ã‚‹ã‹ã‚’ãƒã‚§ãƒƒã‚¯
                // ã“ã®ãƒã‚§ãƒƒã‚¯ã«ã¯å˜èªã®å¢ƒç•Œ(\b)ã¨\w*ãŒå¿…è¦ã§ã™
                const removalTriggerRegex = new RegExp('\\b\\w*(' + containingPatterns.join('|') + ')\\w*\\b', 'gi');
                
                if (removalTriggerRegex.test(processedLine)) {
                    // ã‚‚ã—ãƒˆãƒªã‚¬ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å«ã‚€å˜èªãŒã‚ã‚Œã°ã€è¡Œã‚’ç©ºã«ã™ã‚‹ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
                    shouldEmptyLine = true;
                    // ãã®å¾Œã€è¡Œå…¨ä½“ã‹ã‚‰è©²å½“ã®å˜èªã‚’å‰Šé™¤
                    processedLine = processedLine.replace(removalTriggerRegex, '');
                }

                // D. æœ€çµ‚çš„ãªè¡Œã®å†…å®¹ã‚’æ±ºå®š
                if (shouldEmptyLine) {
                    // ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ãŸã‚‰ã€è¡Œå…¨ä½“ã‚’ç©ºæ–‡å­—åˆ—ã«ã™ã‚‹ï¼ˆè¡Œæ•°ä¿æŒï¼‰
                    return ''; 
                } else {
                    // ãƒ•ãƒ©ã‚°ãŒç«‹ã£ã¦ã„ãªã‘ã‚Œã°ã€éƒ¨åˆ†å‰Šé™¤å¾Œã®è¡Œã‚’è¿”ã™
                    return processedLine;
                }
            });

            // 4. çµæœã®çµåˆã¨å‡ºåŠ›
            const resultText = processedLines.join('\n');
            outputTextarea.value = resultText;
        }
    </script>

</body>
</html>
